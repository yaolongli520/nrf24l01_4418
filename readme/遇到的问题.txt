1.加载驱动前 先加载 spi_gpio_func.ko
否则SPI功能无效

2.NRF24L01_Read_Buf 要拉低片选 发出寄存器地址 再读 最后才能拉高片选

SPI2_ReadWriteByte 用于单周期全双工写入并读出一个字节


3.A发给B 需要 A的发送地址和 B的接收地址一样
 并且A和B的频率要一样


模块的工作频率因避免多射频通道的窜扰而编程可调，为2.4-2.525GHz
提高的0.125GHz频率可以通过05号寄存器也就是RF_CH寄存器进行配置

寄存器的默认状态值应该是0000 0010

F0= 2400 + RF_CH

计算公式是F0= 2400 + RF_CH [MHz]，只要RF_CH寄存器赋值0--125，而且无论是16进制形式的数据0x00--0x7d还是10进制形式的数据0--125都是有效的


新问题 echo 和 cat 命令写入的数据长度不足32字节无法触发一次发送,并且发送方
发送44个字节接收方只收到32个字节。
从驱动程序来看是发送成功了 但是接收方并不会产生中断。因此丢失了,
需要对其进行对齐补0发送


发送64个字节总是丢包,更改为模式1接收。



驱动出现  wait is timeout 模块失控 需要重新上电模块

make_req_pack 然后 del_pack 会出错？
loss_buff_to_pack 中对malloc的内存溢出写


重新刷机发现发送好像没丢包了,丢包可能是磁盘容量不足


驱动程序 nrf24l01_read 中存在bug 比如应用读 992字节
缓存区有1024 返回1024 导致应用空间溢出

write 函数 比如 6000个字节 不要分成 4095+1905
会导致最后一个包出错 应该改为 4064 + 1936

read 函数可以随便读 但是 返回给应用程序尽量要是 32 的整数倍
比如应用缓存6000字节 ,读之前 将缓存全部设置 0xff 
单次最大读 4095 
最后一个包的最后一个数据被认为是0xff
比如驱动程序缓存有 4095个字节 应该先返回 4094 



修改应用和驱动
应用双方都要设置收发地址相同，用于应答 驱动程序才能出现 TX完成的
标志位，从而不会过多的重发导致延迟。

问题偶尔出现超时,超时后收发切换出现问题有时只能发不能收？
[ 2266.916000] wait is timeout

比如10000字节经常出现这个问题
重发BUG: 发送程序,丢失的包是 256 ~ 283 但是构造的包却是 0~27
答:因为包号是 0-255 一个包30字节 最大可传输字节数是 256*30 = 7680

问题怎么接收的百分比会减少???
因为发送方发出后 接收方返回的请求重发发送方收不到,
进而又发了一次新包,接收方解析新包,恰好比第一次少。


完成后退出出现 段出错?
原因是最大 256 个包 但是接收包前把内存全部写入 0xff
比如读取 180个包 第 181 个包 会认为是 包号256 长度256
然后拷贝255个数据导致溢出


出现只能发不能收的时候 好像 0x17 寄存器RXFIFO 是满的
在初始化函数中添加清空 TX RX 缓存的函数


问题2 出现漏洞的原因好像是 在发送过程出现接收的中断
然后发送就出现 timeout 可能每次发完一个数据进入接收模式
的一瞬间，接收到数据 RXFIFO满了 不读取并清空RX FIFO 无法继续发送。

_nrf24l01_set_rx_mode 把切换到rx模式的函数放到wirte 函数最后面
防止发送空隙出现接收模式。

无法发送返回0x0e
wait is timeout sta=0e

发现管道0 自动确定 ENAA_P0 被清0


BUG 未发送完毕禁止切换到接收模式 ！！

内核崩溃 偶尔出现 工作结构导致
kernel BUG at kernel/workqueue.c:1236!
PC is at worker_thread+0x2a4/0x3b0
LR is at get_parent_ip+0x10/0x2c


因为模块在退出后仍然处于接收模式
比如 接收模式收了 200字节还有100 没收 退出了 read函数后
会继续接收这个100字节 但是应用这个时候调用write 接收缓存带有数据
导致 write函数发出出错 
因为接收使用的是中断 
能否进入 write 函数 等待未接收完的事情处理完毕
立马切换发送模式立马切换发送模式,不再处理接收
再进一步处理缓存然后调度发送。


可能遇到比较经典的漏洞

进程A：
调度进程B
设置当前状态为等待完成

进程B
做事
唤醒进程A

在大多数情况 进程A 进入睡眠等待进程B唤醒
但是有特殊情况在进程A 未进入等待的时候B已经做完
进而唤醒在运行的进程A，进程A 未睡眠前忽略唤醒信号
进入了僵尸睡眠。



先设置 flag = 0 
然后再操作
再等待睡眠 
可能没进入睡眠前操作完成，可以不用进行睡眠
 








